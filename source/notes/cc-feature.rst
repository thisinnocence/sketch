C++ 现代特性
=======================

C++11 实用特性
--------------------

- 就地初始化，直接在类内对成员变量进行初始化，简化构造函数， {} 可避免窄化转换, 不涉及窄化转换时可用 ``=`` 进行初始化。
- 统一初始化，使用花括号 ``{}`` 进行初始化，避免了窄化转换，可以初始化数组、容器和类对象。
- 模板变长参数，允许模板接受任意数量和类型的参数，增强了模板的灵活性和可扩展性。
- 模板别名，使用 ``using`` 关键字为模板类型创建别名，简化了复杂类型的使用和阅读。
- 右值引用和移动语义，允许资源的高效转移，减少不必要的拷贝，提高性能。
- 智能指针 ``unique_ptr、shared_ptr、weak_ptr``, 提供自动内存管理，防止内存泄漏和悬空指针。
- ``constexpr`` 允许在编译时计算常量表达式，提高性能和代码的安全性。
- ``override`` 和 ``final`` 关键字，增强了类的继承和多态的安全性和可读性。
- 默认和删除的函数，允许显式地指定类的特殊成员函数的行为，简化了类的设计和实现。
- 委托构造函数，允许一个构造函数调用另一个构造函数，减少代码重复，提高代码的可维护性。
- ``auto`` 关键字，允许编译器自动推导变量的类型，简化了代码的编写和阅读。
- ``for range`` 循环，简化了对容器和数组的遍历，提高了代码的可读性。
- ``nullptr`` 关键字，提供了类型安全的空指针，避免了传统的 NULL 宏带来的问题。
- 强类型枚举，使用 ``enum class`` 定义枚举类型，避免了枚举值的隐式转换和命名冲突。
- 静态断言，使用 ``static_assert`` 在编译时检查条件，提高代码的安全性和正确性。
- 多线程支持，提供了线程、互斥锁、条件变量等多线程编程的基础设施，简化了并发编程。
- 字符串转换函数，提供了更方便和安全的字符串转换函数，如 ``std::to_string`` 和 ``std::stoi``。
- 正则表达式库 ``<regex>`` ，提供了强大的字符串模式匹配和处理功能。
- 时间库 ``<chrono>`` ，提供高精度计时和时间段处理功能。

C++14 实用特性
--------------------

- 函数返回值类型推导，允许编译器自动推导函数的返回类型，简化了函数的定义和阅读。
- ``lambda`` 参数类型可用 auto 推导, 使得lambda更加的强大和灵活。
- ``lambda`` 支持初始化捕获（init-capture），允许 lambda 表达式捕获变量时使用移动语义，增强了 lambda 的性能和安全性。
- 变量模板，允许定义模板变量，简化了常量和静态变量的使用。如： ``template<typename T> constexpr T pi = T(3.14159);``
- ``constexpr`` 增强，允许在 constexpr 函数中使用更多的语句和控制结构，增强了编译时计算的能力。
- ``std::make_unique``，提供了一种安全和简洁的方式来创建 ``std::unique_ptr``，避免了手动使用 new 关键字。
- ``std::shared_timed_mutex``，共享定时互斥锁，允许多个线程同时读取，但只有一个线程可以写入，提高了并发性能，有超时功能。
- ``std::shared_lock``，配合 ``shared_mutex/shared_timed_mutex`` 使用的 RAII 读锁​。
- ``std::integer_sequence``，提供了一种编译时整数序列，简化了模板元编程和参数包展开。
- 二进制字面量，允许使用二进制格式表示整数，增强了代码的可读性和表达能力。如： ``0b1010`` 表示十进制的 10
- 数字分隔符，允许在数字字面量中使用单引号作为分隔符，增强了大数字的可读性。如： ``1'000'000`` 表示一百万。

C++17 实用特性
--------------------

- 结构化绑定，允许将结构体或元组的成员直接绑定到多个变量，简化了代码的编写和阅读，如：方便遍历 ``map/pair`` 等。
- ``if/switch`` 语句中的初始化，允许在 ``if`` 或 ``switch`` 语句中声明和初始化变量，增强了变量的作用域和可读性。
- 内联变量，允许在头文件中定义变量而不会导致重复定义错误，简化了常量和静态变量的使用，如 ``inline int global_var = 42``;
- 类模板参数推导，允许编译器自动推导构造函数模板的参数类型，简化了模板类的使用和实例化。
- 折叠表达式，允许对参数包进行递归操作，简化了模板元编程和参数包展开。
- 嵌套命名空间namespace定义简写，简化了命名空间的组织和管理。
- ``[[nodiscard]], [[maybe_unused]], [[fallthrough]]`` 等属性，增强了代码的安全性和可读性。
- ``std::variant``，提供了一种类型安全的联合体，可以存储不同类型的值，增强了类型的灵活性和安全性, 里面可以有string等复杂类型。
- ``std::optional``，表示一个可能包含值也可能不包含值的对象，简化了可选值的处理和检查。
- ``std::any``，提供了一种类型安全的容器，可以存储任意类型的值，增强了类型的灵活性和安全性。
- ``std::apply``，允许将函数应用于参数包，简化了函数调用和参数传递。
- ``std::make_from_tuple``，允许从元组创建对象，简化了对象的构造和初始化。
- ``std::string_view``，提供了一种轻量级的字符串视图，避免了不必要的字符串拷贝，提高性能。
- ``std::filesystem``，提供了一套跨平台的文件系统操作接口，简化了文件和目录的管理和操作。
- ``as_const`` 函数，是 <utility> 中的一个函数模板，作用是返回 const T&, 新增的工具函数。
- ``constexpr if`` 在编译期根据条件选择代码分支，避免无效代码实例化，简化模板元编程逻辑。
- ``std::scoped_lock`` C++17 引入的 RAII 锁管理器，可同时安全锁定多个互斥量，避免死锁。

C++20 实用特性
--------------------

- modules，提供了一种新的代码组织和管理方式，替代了传统的头文件和预处理器指令，提高了编译速度和代码的可维护性。
- ranges, 提供了一套新的范围库，简化了对容器和序列的操作和处理，增强了代码的表达能力和可读性。
- concepts，提供了一种新的模板约束机制，增强了模板的类型安全性和可读性。
- coroutines，提供了一种新的异步编程模型，简化了异步代码的编写和管理，提高了代码的可读性和性能。
- lambda 表达式更新，支持使用模板参数，constexpr确认，对 =this 的捕获等。
- constexpr 增强：大量标准库算法和容器操作被标记为 constexpr 使用，更多代码编译期执行。
- std::format ，提供了一种类型安全且灵活的字符串格式化方式，替代了传统的 printf 风格格式化。
- ``<=>`` 三路比较运算符（太空船操作符），简化了自定义类型的比较操作，自动生成所有比较运算符。
