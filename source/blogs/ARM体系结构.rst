.. Michael Wu 版权所有

:Authors: Michael Wu
:Version: 1.0

ARM体系结构
===========

ARMv8异常等级和安全态
------------------------

ARMv8-A 有两种 security states, Secure and Non-secure. The Non-secure state 也叫做 Normal World. 

.. image:: pic/Exception-level.png
    :scale: 50%


AArch64 Exception Handling
^^^^^^^^^^^^^^^^^^^^^^^^^^^

异常会中断正常执行流程，并且需要特权程序进行异常处理，从而确保系统正常运行。Exception包括：

- Interrupts.
- Memory system aborts.
- Exceptions generated by attempting to execute an instruction that is UNDEFINED.
- System calls.
- Secure monitor or Hypervisor traps.
- Debug exceptions

| ARM CPU的执行mode改变受到特权程序控制或者异常自动触发。可以参考：
| https://developer.arm.com/documentation/den0024/a/Fundamentals-of-ARMv8/Changing-Exception-levels

.. image:: pic/arm-pe-mode.png
    :scale: 60%

执行这些指令可能会引发异常。以请求运行在更高特权级别的软件提供的服务：

.. note:: 

  - The Supervisor Call (SVC) instruction enables User mode programs to request an OS service.
  - The Hypervisor Call (HVC) instruction enables the guest OS to request hypervisor services.
  - The Secure monitor Call (SMC) instruction enables the Normal world to request Secure world services.

Reset异常比较特殊，异常向量表地址可以从 ``Reset Vector Base Address`` 寄存器 ``RVBAR_ELn`` 中读取。
所有核都有一个 ``reset input`` ，reset是最高优先级的异常，无法被mask屏蔽，用于核上电初始化。

Exception and Interrupt
^^^^^^^^^^^^^^^^^^^^^^^^^

| 每种exception都有一个关联的异常handler。当异常被处理后，特权软件恢复到异常前的执行状态。
| https://developer.arm.com/documentation/100933/latest/AArch64-Exception-and-Interrupt-Handling

.. note:: 

  异常和中断的区别:

  - An exception is an event (other than branch or jump instructions) that causes the normal sequential execution
    of instructions to be modified.
  - An interrupt is an exception that is not caused directly by program execution. Usually, hardware external to the 
    processor core signals an interrupt, such as a button being pressed.

  ARM把exception分为同步和异步两组:

  - The synchronous exception types can have many causes but they are handled in a similar way. 
  - The asynchronous exception type is subdivided into three interrupt types, IRQ, FIQ, and SError (System Error).

.. _int_id_type:

GIC中断控制器
----------------

主要参考ARM官方文档:  https://developer.arm.com/documentation/ihi0069/h/?lang=en

GIC的组成和中断的分类：

.. image:: pic/gic-compose.png
    :scale: 60%

| 按照中断号分：
| https://developer.arm.com/documentation/198123/0302/Arm-GIC-fundamentals

.. list-table::
   :header-rows: 1

   * - INTID
     - Interrupt Type
     - Notes
   * - 0-15
     - SGIs
     - Banked per PE
   * - | 16-31
       | 1056-1119 (GICv3.1)
     - PPIs
     - Banked per PE
   * - | 32-1019
       | 4096-5119 (GICv3.1)
     - SPIs
     -
   * - 1020-1023
     - Special interrupt number
     - Used to signal special cases, see Settings for each PE for more information.
   * - 1024-8191
     - Reserved
     -
   * - 8192 and greater
     - LPIs
     - The upper boundary is IMPLEMENTATION DEFINED

然后中断的上报流程可以看，不包括LPI（都是消息中断)：

.. image:: pic/gic_step.png
    :scale: 50%

按照安全非安全进行分组如下，以及对应的使用场景：

.. image:: pic/gic_safe_group.png
    :scale: 45%

| 下面从软件使能GIC视角讲了一些原理和用法:
| https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling/The-Generic-Interrupt-Controller

**Distributor**

  To which all interrupt sources in the system are connected. The Distributor determines the highest priority 
  pending interrupt that can be delivered to a core and forwards that to the CPU interface of the core.

  The Distributor provides registers which report the current state of the different interrupt IDs..

**CPU interface**

  Through which a core receives an interrupt. The CPU interface hosts registers to
  mask, identify and control states of interrupts forwarded to that core. 

  The core executes the exception handler in response. The handler must query the interrupt ID
  from a CPU interface register and begin servicing the interrupt source. When finished, the
  handler must write to a CPU interface register to report the end of processing.

**Interrupt state**

  - Inactive -> Pending
      When the interrupt is asserted by the peripheral.
  - Pending -> Active
      When the handler acknowledges the interrupt.
  - Active -> Inactive
      When the handle has finished dealing with the interrupt

**Configure and Initialization**

  The GIC is accessed as a memory-mapped peripheral. All cores can access the common
  Distributor, but the CPU interface is banked, that is, each core uses the same address to access
  its own private CPU interface. It is not possible for a core to access the CPU interface of another
  core.

  The Distributor hosts a number of registers that you can use to configure the properties of
  individual interrupts.

  The Distributor also provides priority masking by which interrupts below a certain priority are
  prevented from reaching the core. The distributor uses this when determining whether a pending
  interrupt can be forwarded to a particular core.

  The CPU interfaces on each core helps with fine-tuning interrupt control and handling on that core.

  Both the Distributor and the CPU interfaces are disabled at reset. The GIC must be initialized
  after reset before it can deliver interrupts to the core.

  In the Distributor, software must configure the priority, target, security and enable individual
  interrupts.

  Before interrupts are expected in the core, software prepares the core to take interrupts by setting
  a valid interrupt vector in the vector table, and clearing interrupt mask bits in PSTATE, and setting
  the routing controls. For an interrupt to reach the core, the individual interrupt, Distributor and CPU interface 
  must all be enabled. The interrupt also needs to be of sufficient priority, that is, higher than the core's
  priority mask.

**Interrupt handling**

  When the core takes an interrupt, it jumps to the top-level interrupt vector obtained from the
  vector table and begins execution.

  The top-level interrupt handler reads the Interrupt Acknowledge Register from the CPU Interface block to 
  obtain the interrupt ID. As well as returning the interrupt ID, the read causes the interrupt to be marked 
  as active in the Distributor. 

  When the device-specific handler finishes execution, the top-level handler writes the same
  interrupt ID to the End of Interrupt (EoI) register in the CPU Interface.

  It is possible for there to be more than one interrupt waiting to be serviced on the same core, but
  the CPU Interface can signal only one interrupt at a time. The top-level interrupt handler could
  repeat the above sequence until it reads the special interrupt ID value 1023, indicating that there
  are no more interrupts pending at this core. This special interrupt ID is called the spurious
  interrupt ID.

  The spurious interrupt ID is a reserved value, and cannot be assigned to any device in the
  system. When the top-level handler has read the spurious interrupt ID it can complete its
  execution, and prepare the core to resume the task it was doing before taking the interrupt.

结合QEMU和Linux的源码实现，可以更好的理解其实现细节。

ARM architected timer(arch_timer)
------------------------------------

主要参考：

| https://developer.arm.com/documentation/102379/0103/The-processor-timers
| https://www.kernel.org/doc/Documentation/devicetree/bindings/arm/arch_timer.txt

The Generic Timer includes a ``System Counter`` and set of **per-core timers**.

The ``System Counter`` is an always-on device, which provides a fixed frequency **incrementing**
system count. The system count value is broadcast to all the cores in the system, giving the cores
a common view of the passage of time. 

Software can configure timers to generate interrupts or events in set points in the future.
Software can also use the system count to add timestamps, because the system count gives a common
reference point for all cores.

| 针对Server Base System Architecture (SBSA)的推荐中断ID配置：
| (csv转表格VSCO的插件真的好用^_^)

+-------------------------------+------------------------+
| Timer                         | SBSA recommended INTID |
+===============================+========================+
| EL1 Physical Timer            | 30                     |
+-------------------------------+------------------------+
| EL1 Virtual Timer             | 27                     |
+-------------------------------+------------------------+
| Non-secure EL2 Physical Timer | 26                     |
+-------------------------------+------------------------+
| Non-secure EL2 Virtual Timer  | 28                     |
+-------------------------------+------------------------+
| EL3 Physical Timer            | 29                     |
+-------------------------------+------------------------+
| Secure EL2 Physical Timer     | 20                     |
+-------------------------------+------------------------+
| Secure EL2 Virtual Timer      | 19                     |
+-------------------------------+------------------------+

.. note:: 
  These INTIDs are in the Private Peripheral Interrupt (PPI) range. These INTIDs are
  private to a specific core. This means that each core sees its EL1 physical timer as
  INTID 30. 

看下 QEMU virt-machine dts里的timer配置, see :ref:`virt_dts`

.. code-block:: dts

    timer {
      interrupts = <0x01 0x0d 0x304 0x01 0x0e 0x304 0x01 0x0b 0x304 0x01 0x0a 0x304>;
      always-on;
      compatible = "arm,armv8-timer\0arm,armv7-timer";
    };

都是 non-spi 中断，显然这是ppi，然后中断号: 0xd(13) 0x0e(14) 0x0b(11) 0x0a(10), 对应QEMU代码是

.. code-block:: c

  /* These are architectural INTID values */
  #define VIRTUAL_PMU_IRQ            23
  #define ARCH_GIC_MAINT_IRQ         25
  #define ARCH_TIMER_NS_EL2_IRQ      26
  #define ARCH_TIMER_VIRT_IRQ        27
  #define ARCH_TIMER_NS_EL2_VIRT_IRQ 28
  #define ARCH_TIMER_S_EL1_IRQ       29
  #define ARCH_TIMER_NS_EL1_IRQ      30

  #define INTID_TO_PPI(irq) ((irq) - 16)

减去了16，加上后就对上了，看来配置PPI的时候，硬件的编号配置到DTS里时，也是减去了16，前16个是SGI，这样又是从0开始了。

针对 Physical timers 和 Virtual timers :

- Physical timers,  compare against the count value provided by the System Counter.
- Virtual timers, compare against a virtual count. Virtual count计算方法: ``Virtual Count = Physical Count - <offset>``

还需要配合内核看下对应处理。